//
// 3Dify App
//
// Project website: https://github.com/3dify-app
//
// Authors:
// - Philipp Matthes 2020, Contact: mail@philippmatth.es
//
// Copyright notice: All rights reserved by the authors given above. Do not
// remove or change this copyright notice without confirmation of the authors.
//

// The sample size of the kernel
#define KERNEL_SIZE 11
// Inverse square root of pi times 2
#define INV_SQRT_PI_2 0.3989422803

// Compute the normal probability distribution on a float value.
float normpdf(float x, float sigma) {
    return INV_SQRT_PI_2 * exp(-0.5 * x * x / (sigma * sigma)) / sigma;
}

// Compute the normal probability distribution on a 3-dimensional vector.
float normpdf3(vec3 v, float sigma) {
    return INV_SQRT_PI_2 * exp(-0.5 * dot(v, v) / (sigma * sigma)) / sigma;
}

// Blur the input depth image but preserve Edges from the diffuse map.
kernel vec4 BilateralFilter(
    sampler diffuse,
    sampler depth,
    float sigmaR,
    float sigmaS
) {
    const int kernelRadius = (KERNEL_SIZE - 1) / 2;
    vec3 finalColor = vec3(0.0);

    float conv[KERNEL_SIZE];
    for (int i = 0; i <= kernelRadius; i++) {
        float value = normpdf(float(i), sigmaR);
        conv[kernelRadius + i] = value;
        conv[kernelRadius - i] = value;
    }

    float normalizationFactor = 0.0;

    vec2 diffuseSize = samplerSize(diffuse);
    vec2 depthSize = samplerSize(depth);
    float scaleX = diffuseSize.x / depthSize.x;
    float scaleY = diffuseSize.y / depthSize.y;

    vec2 pixelCoordinates = samplerCoord(diffuse);

    vec3 diffusePixel = sample(diffuse, pixelCoordinates).rgb;
    vec3 depthPixel = sample(depth, pixelCoordinates).rgb;

    float spacialWeightBaseReference = 1.0 / normpdf(0.0, sigmaS);

    for (int i = -kernelRadius; i <= kernelRadius; i++) {
        for (int j = -kernelRadius; j <= kernelRadius; j++) {
            vec2 offsetVector = vec2(i / diffuseSize.x, j / diffuseSize.y);
            vec2 offsetCoord = pixelCoordinates + offsetVector;
            vec3 offsetDiffusePixel = sample(diffuse, offsetCoord).rgb;
            vec3 offsetDepthPixel = sample(depth, offsetCoord).rgb;

            vec3 dist = offsetDiffusePixel - diffusePixel;

            float range = conv[kernelRadius + i] * conv[kernelRadius + j];
            float spacial = normpdf3(dist, sigmaS) * spacialWeightBaseReference;
            float weight = range * spacial;

            finalColor += weight * offsetDiffusePixel;
            normalizationFactor += weight;
        }
    }

    return vec4(finalColor, 1.0);
}
